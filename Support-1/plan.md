# План сопровождения Vigilos CE 2.0

## Что надо сделать
- Поднять рабочее окружение (Go 1.21, Docker, docker-compose) и собрать placeholder сервис `cmd/vigilos-core`.
- Настроить базовый цикл сборки: скрипты `infra/scripts/build/*` и dev Dockerfile/compose.
- Проверить структуру репозитория, документацию в `docs/` и конфиг `editions.yaml`.
- Подготовить черновые артефакты: образы (dev/prod), бинарь `bin/vigilos-core`, схемы взаимодействий.
- Закрепить процессы: CI воркфлоу, правила тестирования, критерии приемки.

## Как это должно работать
- В dev режиме `docker-compose -f infra/scripts/docker/dev/docker-compose.dev.yml up` собирает образ из `infra/scripts/docker/dev/Dockerfile.dev`, копирует контекст `vigilos/` и запускает `go run ./cmd/vigilos-core`.
- Скрипты `infra/scripts/build/build-go.sh|build-cpp.sh|build-web.sh` выполняют статические placeholder-сборки без обязательных зависимостей.
- Конфиг редакций (`editions.yaml`) и заготовленные пакеты в `internal/licensing`, `internal/camera`, `internal/media`, `internal/events` задают будущие флоу (камера → медиапрокси → аналитика → события → API/WebSocket).
- Документация и placeholders в `docs/` описывают целевую архитектуру, требования и дорожную карту.

## Какие инструменты понадобятся
- Go 1.21+, Docker 24+, docker-compose v2, Bash (для build-скриптов), PowerShell (Windows).
- GitHub Actions (воркфлоу `pr-checks`, `build-develop`, `release`), git.
- Базовые линтеры/форматтеры: `go fmt` (уже в CI), опционально golangci-lint/clang-tidy/ESLint.

## Какая информация потребуется
- Доступные RTSP/ONVIF потоки (для будущих интеграционных тестов).
- Целевые платформы/архитектуры сборки (linux/amd64, arm64; NAS специфики).
- Требования по БД (SQLite/PostgreSQL/TimescaleDB) и хранилищам (SMB/NFS) — сейчас placeholders.
- Политики лицензирования/редакций: актуальные лимиты камер, ключи для `vigilos-validator`.

## Как должен выглядеть результат
- Рабочее dev окружение: `docker-compose.dev.yml` поднимает контейнер, сервис печатает placeholder баннер.
- Сборка проходит: `infra/scripts/build/build-go.sh` создает `bin/vigilos-core` (или завершается без критичной ошибки), CI воркфлоу зеленые.
- Документы в `docs/` дополнены ссылкой на этот план (`Support-1/plan.md`) и описывают следующую фазу работ.
- Папка `Support-1` содержит актуальный план и критерии проверки.

## Из каких шагов состоит реализация
1. Подготовка окружения и зависимостей.
2. Проверка структуры репозитория и актуальности placeholders.
3. Сборка dev образа и локальный запуск.
4. Прогон базовых проверок (go fmt/go test, если добавятся тесты).
5. Обновление/уточнение документации и чек-листов.
6. Планирование следующих инкрементов (камера, медиапоток, лицензирование).

## Что надо сделать на каждом шаге
- Шаг 1: Установить Go 1.21, Docker, проверить `$PATH`; подтянуть модули `go mod download` (толерантно к отсутствующим deps).
- Шаг 2: Просмотреть `README.md`, `docs/architecture.md`, `docs/tasks.md`, сверить пути в `infra/scripts/docker/*`.
- Шаг 3: Выполнить `docker-compose -f infra/scripts/docker/dev/docker-compose.dev.yml build && ... up`, убедиться что `COPY . ./` в Dockerfile.dev использует корень контекста.
- Шаг 4: Запустить `go fmt ./...` и `go test ./...` (ожидается успех либо отсутствие тестов).
- Шаг 5: Зафиксировать изменения в `Support-1/plan.md`, при необходимости дополнить `docs/` ссылками и уточнениями.
- Шаг 6: Согласовать следующий backlog по `docs/tasks.md` и подготовить задачи под спринт 1.x.

## Как поймем, что всё работает как надо
- `docker-compose.dev` собирается и запускается без ошибок; в логах контейнера видно `Vigilos Core placeholder: implement services in internal/`.
- `go fmt ./...` не возвращает диффов; `go test ./...` завершается с кодом 0 (или с ожидаемыми skip для отсутствующих тестов).
- Скрипты `infra/scripts/build/*.sh` исполняются без необработанных ошибок (могут выводить placeholder).
- CI воркфлоу (`pr-checks`, `build-develop`) проходят на ветке.

## Как ничего не сломать в процессе
- Работать в отдельной ветке, не трогать чужие незавершенные изменения.
- Не менять контекст сборки Docker: оставлять `context: ../../..` и `COPY . ./` в dev Dockerfile.
- Держать изменения в Go-коде форматированными (`go fmt`), проверять логи сборки перед пушем.
- Документы обновлять атомарно, фиксировать версии инструментов и команды запуска.

