# План разработки Local-video-server

## 1. Выбор технологического стека

### Основной язык: **Go (Golang)**

**Причины выбора:**
- Кроссплатформенность (единый бинарник для Windows/Linux/macOS/ARM)
- Высокая производительность (компилируемый язык)
- Встроенная поддержка конкурентности (горутины)
- Богатая стандартная библиотека для сетевых операций
- Статическая линковка (нет зависимостей от среды)
- Малое потребление памяти

**Альтернативы с обоснованием отказа:**
- **Rust:** Слишком сложная кривая обучения, избыточность для задачи
- **Python:** Низкая производительность, зависимость от интерпретатора
- **C++:** Сложность кроссплатформенной разработки
- **Java:** Требует JVM, высокое потребление памяти

### Дополнительные инструменты и библиотеки:
- `github.com/google/gopacket` - анализ сетевых пакетов
- `github.com/Ullaakut/nmap` - интеграция с nmap
- `github.com/gvallve/go-rtsp` - RTSP клиент
- `github.com/use-go/onvif` - ONVIF клиент
- `github.com/pion/webrtc` - WebRTC
- **FFmpeg** (CLI) - для проверки RTSP потоков и получения параметров

---

## 2. Архитектура приложения

```
┌─────────────────────────────────────────────────────────┐
│                    Local-video-server                    │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────┐ │
│  │   Network    │    │   Protocol   │    │   RTSP   │ │
│  │   Scanner    │───▶│  Detector    │───▶│  Checker  │ │
│  ┌──────────────┘    ┌──────────────┘    ┌──────────┘ │
│         │                   │                   │       │
│         ▼                   ▼                   ▼       │
│  ┌──────────────────────────────────────────────────┐  │
│  │         Device Discovery & Registry              │  │
│  └──────────────────────────────────────────────────┘  │
│         │                                               │
│         ▼                                               │
│  ┌──────────────────────────────────────────────────┐  │
│  │         Results Storage & Export                  │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### Компоненты системы:

1. **Network Scanner** - Сканирование локальной сети
2. **Protocol Detector** - Определение протоколов на устройствах
3. **RTSP Checker** - Проверка RTSP каналов и получение параметров
4. **Device Registry** - Хранение информации об обнаруженных устройствах
5. **Results Export** - Экспорт результатов в различные форматы

---

## 3. Структура проекта

```
Local-video-server/
├── cmd/
│   └── server/
│       └── main.go                 # Точка входа приложения
├── internal/
│   ├── scanner/
│   │   ├── network.go            # Сканирование сети (ARP, порты)
│   │   ├── onvif.go              # ONVIF Discovery
│   │   ├── upnp.go               # UPnP/SSDP Discovery
│   │   └── detector.go           # Определение протоколов
│   ├── rtsp/
│   │   ├── checker.go            # Проверка RTSP каналов
│   │   ├── parser.go             # Парсинг RTSP ответов
│   │   └── ffmpeg.go             # Интеграция с FFmpeg
│   ├── protocols/
│   │   ├── rtsp.go               # RTSP клиент
│   │   ├── rtmp.go               # RTMP детектор
│   │   ├── hls.go                # HLS детектор
│   │   ├── webrtc.go             # WebRTC детектор
│   │   ├── mjpeg.go              # MJPEG детектор
│   │   └── dash.go               # MPEG-DASH детектор
│   ├── models/
│   │   ├── device.go             # Модель устройства
│   │   ├── stream.go             # Модель потока
│   │   └── config.go             # Конфигурация
│   ├── storage/
│   │   └── registry.go           # Хранение результатов
│   └── export/
│       ├── json.go               # Экспорт в JSON
│       ├── csv.go                # Экспорт в CSV
│       └── xml.go                # Экспорт в XML
├── pkg/
│   └── utils/
│       ├── network.go             # Утилиты для работы с сетью
│       └── logger.go             # Логирование
├── configs/
│   └── config.yaml               # Конфигурационный файл
├── go.mod                        # Go модули
├── go.sum                        # Зависимости
├── Makefile                      # Сборка и задачи
├── README.md                     # Документация
└── DEVELOPMENT_PLAN.md           # Этот файл
```

---

## 4. План разработки

### Этап 1: Подготовка (1-2 недели)

#### 1.1. Установка Go 1.21+
- [ ] Установка Go на всех целевых платформах
- [ ] Настройка переменных окружения
- [ ] Проверка версии и работоспособности

#### 1.2. Настройка проекта структуры:
```
/cmd/scanner      - основной исполняемый файл
/internal/        - внутренние пакеты
    /network/     - сканирование сети
    /protocols/   - реализация протоколов
    /detection/   - обнаружение камер
    /utils/       - утилиты
/pkg/            - публичные пакеты
/configs/        - конфигурации
/tests/          - тесты
```

#### 1.3. Настройка CI/CD (GitHub Actions)
- [ ] Настройка автоматической сборки
- [ ] Тестирование на разных платформах
- [ ] Автоматическое создание релизов

#### 1.4. Выбор библиотек:
- [ ] github.com/google/gopacket - анализ сетевых пакетов
- [ ] github.com/Ullaakut/nmap - интеграция с nmap
- [ ] github.com/gvallve/go-rtsp - RTSP клиент
- [ ] github.com/use-go/onvif - ONVIF клиент
- [ ] github.com/pion/webrtc - WebRTC
- [ ] Настройка go.mod и зависимостей

**Результат:** Рабочий каркас приложения с конфигурацией и логированием

---

### Этап 2: Ядро сканирования сети (2-3 недели)

#### 2.1. Модуль сетевого сканирования:
- [ ] Определение активных подсетей
- [ ] ARP-сканирование для локальных устройств
- [ ] ICMP ping sweep
- [ ] Сканирование портов (554 RTSP, 80 HTTP, 1935 RTMP и т.д.)
- [ ] Параллельное сканирование с ограничением потоков

#### 2.2. Дискавери служб:
- [ ] Автоматическое определение типов устройств
- [ ] Фильтрация по MAC-адресам производителей
- [ ] База сигнатур видеокамер

#### 2.3. Конфигурация:
- [ ] Файлы конфигурации YAML/JSON
- [ ] Параметры сканирования (таймауты, диапазоны)
- [ ] Белый/черный списки

**Результат:** Обнаружение устройств в локальной сети различными методами

---

### Этап 3: Реализация протоколов (4-6 недель)

**Приоритет протоколов:**

#### 3.1. ONVIF (WS-Discovery + SOAP)
- [ ] Обнаружение устройств
- [ ] Получение capabilities
- [ ] Получение RTSP URL
- [ ] WS-Discovery multicast на 239.255.255.250:3702
- [ ] SOAP запросы GetCapabilities, GetProfiles
- [ ] Получение RTSP URL из GetStreamUri

#### 3.2. RTSP (Real Time Streaming Protocol)
- [ ] OPTIONS, DESCRIBE запросы
- [ ] Парсинг SDP (Session Description Protocol)
- [ ] Проверка доступности потоков
- [ ] Поддержка Basic/Digest auth
- [ ] Последовательность: OPTIONS → DESCRIBE → SETUP → PLAY
- [ ] Парсинг SDP для параметров видео
- [ ] Поддержка TCP/UDP транспорта

#### 3.3. HTTP/HTTPS протоколы:
- [ ] MJPEG: проверка /video или /mjpeg endpoints
- [ ] HLS: обнаружение .m3u8 плейлистов
- [ ] MPEG-DASH: обнаружение .mpd манифестов
- [ ] Проверка веб-интерфейсов камер
- [ ] HTTP GET запросы на возможные endpoints
- [ ] Парсинг manifest файлов
- [ ] Проверка доступности сегментов

#### 3.4. RTMP (Real-Time Messaging Protocol)
- [ ] Handshake protocol
- [ ] Проверка доступности потоков

#### 3.5. WebRTC
- [ ] Обнаружение STUN/TURN серверов
- [ ] Проверка ICE кандидатов
- [ ] Анализ SDP offer/answer
- [ ] Использование pion/webrtc библиотеки
- [ ] Создание offer SDP
- [ ] Анализ ICE кандидатов

#### 3.6. SIP (Session Initiation Protocol)
- [ ] OPTIONS запросы
- [ ] Регистрация в системе
- [ ] Получение информации об устройствах

#### 3.7. RTP/RTCP
- [ ] Анализ потоков RTP
- [ ] Проверка синхронизации
- [ ] Анализ качества потока

**Результат:** Определение всех поддерживаемых протоколов на каждом устройстве

---

### Этап 4: Интеграция и парсинг (2-3 недели)

#### 4.1. Унифицированный интерфейс для всех протоколов
- [ ] Общий интерфейс для работы с протоколами
- [ ] Абстракция над различными реализациями
- [ ] Единый формат данных

#### 4.2. Парсинг параметров камер:
- [ ] Разрешение видео
- [ ] Кодеки (H.264, H.265, MJPEG)
- [ ] Битрейт
- [ ] FPS
- [ ] Настройки качества
- [ ] URI потоков

#### 4.3. Кэширование результатов
- [ ] Кэширование обнаруженных устройств
- [ ] Кэширование параметров потоков
- [ ] Управление временем жизни кэша

#### 4.4. Обработка ошибок и таймаутов
- [ ] Graceful handling ошибок сети
- [ ] Retry механизм для неудачных запросов
- [ ] Настраиваемые таймауты
- [ ] Продолжение работы при ошибках отдельных устройств

**Результат:** Полная информация о всех каналах с параметрами настроек

---

### Этап 5: Интерфейс и отчеты (2-3 недели)

#### 5.1. CLI интерфейс:
- [ ] Разные режимы сканирования (быстрый/полный)
- [ ] Фильтрация результатов
- [ ] Экспорт в JSON/CSV/XML
- [ ] Красивый вывод в консоль
- [ ] Цветной вывод для терминала
- [ ] Табличное представление результатов
- [ ] Детальный вывод по запросу

#### 5.2. REST API (опционально):
- [ ] HTTP сервер для удаленного управления
- [ ] WebSocket для реального времени
- [ ] Документация Swagger/OpenAPI

#### 5.3. Формирование отчетов:
- [ ] Детальная информация о каждой камере
- [ ] Статистика сети
- [ ] Рекомендации по безопасности

**Результат:** Сохранение и экспорт результатов в различных форматах

---

### Этап 6: Оптимизация и безопасность (1-2 недели)

#### 6.1. Оптимизация производительности:
- [ ] Пулы соединений
- [ ] Параллельное выполнение проверок
- [ ] Кэширование DNS
- [ ] Graceful shutdown
- [ ] Оптимизация параллельного сканирования
- [ ] Настройка таймаутов

#### 6.2. Безопасность:
- [ ] Проверка на уязвимости (простые пароли)
- [ ] Шифрование конфигураций
- [ ] Аудит доступа
- [ ] Логирование событий
- [ ] Rate limiting для избежания DoS
- [ ] Уважение к таймаутам устройств
- [ ] Обработка нестандартных реализаций протоколов

#### 6.3. Тестирование:
- [ ] Юнит-тесты (60%+ покрытие)
- [ ] Интеграционные тесты с реальными камерами
- [ ] Фаззинг протоколов
- [ ] Нагрузочное тестирование

**Результат:** Оптимизированное и стабильное приложение

### Этап 7: Сборка и дистрибуция (1 неделя)

#### 7.1. Кроссплатформенная сборка:
- [ ] Windows (x86, x64)
- [ ] Linux (x64, ARM, ARM64)
- [ ] macOS (Intel, Apple Silicon)

#### 7.2. Создание пакетов:
- [ ] .deb/.rpm для Linux
- [ ] .msi для Windows
- [ ] .dmg для macOS
- [ ] Docker образ

#### 7.3. Документация:
- [ ] README с примерами
- [ ] man-страницы
- [ ] Примеры конфигураций

---

## 5. Технические детали реализации

### 5.1. Сканирование сети

```go
// Псевдокод основной логики
func ScanNetwork(subnet string) []Device {
    devices := []Device{}
    
    // 1. Получить список активных хостов
    hosts := getActiveHosts(subnet)
    
    // 2. Параллельное сканирование
    var wg sync.WaitGroup
    results := make(chan Device, len(hosts))
    
    for _, host := range hosts {
        wg.Add(1)
        go func(ip string) {
            defer wg.Done()
            device := scanDevice(ip)
            if device != nil {
                results <- *device
            }
        }(host)
    }
    
    go func() {
        wg.Wait()
        close(results)
    }()
    
    for device := range results {
        devices = append(devices, device)
    }
    
    return devices
}
```

### 5.2. RTSP проверка

```go
// Псевдокод RTSP проверки
func CheckRTSPStream(url string) (*StreamInfo, error) {
    // 1. Подключение к RTSP серверу
    conn, err := net.Dial("tcp", extractHost(url))
    if err != nil {
        return nil, err
    }
    defer conn.Close()
    
    // 2. Отправка OPTIONS
    optionsReq := buildRTSPRequest("OPTIONS", url)
    conn.Write(optionsReq)
    
    // 3. Отправка DESCRIBE
    describeReq := buildRTSPRequest("DESCRIBE", url)
    conn.Write(describeReq)
    
    // 4. Парсинг SDP ответа
    response := readResponse(conn)
    sdp := parseSDP(response)
    
    // 5. Извлечение параметров
    streamInfo := extractStreamInfo(sdp)
    
    return streamInfo, nil
}
```

### 5.3. Модели данных

```go
// Device - обнаруженное устройство
type Device struct {
    IP          string            `json:"ip"`
    MAC         string            `json:"mac,omitempty"`
    Hostname    string            `json:"hostname,omitempty"`
    Manufacturer string           `json:"manufacturer,omitempty"`
    Model       string            `json:"model,omitempty"`
    Protocols   []Protocol        `json:"protocols"`
    RTSPStreams []RTSPStreamInfo  `json:"rtsp_streams,omitempty"`
    DiscoveredAt time.Time        `json:"discovered_at"`
}

// Protocol - поддерживаемый протокол
type Protocol struct {
    Type        string   `json:"type"` // RTSP, RTMP, HLS, etc.
    Port        int      `json:"port"`
    URL         string   `json:"url,omitempty"`
    Available   bool     `json:"available"`
}

// RTSPStreamInfo - информация о RTSP потоке
type RTSPStreamInfo struct {
    URL         string   `json:"url"`
    Codec       string   `json:"codec"`       // H.264, H.265, MJPEG
    Resolution  string   `json:"resolution"`  // 1920x1080
    FPS         float64  `json:"fps"`
    Bitrate     int      `json:"bitrate,omitempty"`
    AudioCodec  string   `json:"audio_codec,omitempty"`
    Channels    int      `json:"channels,omitempty"`
    Available   bool     `json:"available"`
}
```

### 5.4. Детальная реализация протоколов

#### Структура для хранения информации о камере

```go
// Пример структуры для хранения информации о камере
type CameraInfo struct {
    IPAddress     net.IP
    MACAddress    string
    Manufacturer  string
    Model         string
    Protocols     []ProtocolInfo
    RTSPStreams   []RTSPStream
    Vulnerabilities []Vulnerability
    DiscoveryTime time.Time
}

type ProtocolInfo struct {
    Protocol    string  // "RTSP", "ONVIF", etc.
    Port        int
    AuthRequired bool
    AuthType    string  // "none", "basic", "digest"
    URI         string
    Supported   bool
}

type RTSPStream struct {
    Path        string    // e.g., "/live/main"
    Resolution  string    // e.g., "1920x1080"
    Codec       string    // e.g., "H.264"
    Framerate   float64
    Bitrate     int       // kbps
    Quality     string
}
```

#### Особенности реализации для каждого протокола:

**ONVIF:**
- WS-Discovery multicast на 239.255.255.250:3702
- SOAP запросы GetCapabilities, GetProfiles
- Получение RTSP URL из GetStreamUri

**RTSP:**
- Последовательность: OPTIONS → DESCRIBE → SETUP → PLAY
- Парсинг SDP для параметров видео
- Поддержка TCP/UDP транспорта

**WebRTC:**
- Использование pion/webrtc библиотеки
- Создание offer SDP
- Анализ ICE кандидатов

**HLS/MPEG-DASH:**
- HTTP GET запросы на возможные endpoints
- Парсинг manifest файлов
- Проверка доступности сегментов

### 5.5. Оптимизации сканирования

```go
// Стратегия сканирования
1. Быстрое сканирование (30 секунд):
   - ONVIF Discovery
   - Проверка стандартных портов
   - Проверка известных URL камер

2. Полное сканирование (5-10 минут):
   - Полный диапазон портов
   - Глубокий анализ каждого протокола
   - Попытка аутентификации с дефолтными паролями
   - Анализ всех возможных потоков
```

---

## 6. Зависимости (go.mod)

```go
module github.com/yourusername/local-video-server

go 1.21

require (
    // ONVIF
    github.com/use-go/onvif v0.0.0-20231025082739-ff6e66b2e8f5
    
    // Сетевое сканирование
    github.com/google/gopacket v1.1.19
    
    // HTTP клиент
    github.com/go-resty/resty/v2 v2.11.0
    
    // Конфигурация
    gopkg.in/yaml.v3 v3.0.1
    
    // Логирование
    github.com/sirupsen/logrus v1.9.3
    
    // Утилиты
    github.com/spf13/cobra v1.8.0  // CLI
    github.com/spf13/viper v1.18.2 // Конфигурация
)
```

---

## 7. Пример использования

### Командная строка:

```bash
# Сканирование всей локальной сети
./local-video-server scan

# Сканирование конкретной подсети
./local-video-server scan --subnet 192.168.1.0/24

# Сканирование с проверкой RTSP
./local-video-server scan --check-rtsp

# Экспорт результатов
./local-video-server scan --export json --output results.json

# Детальный вывод
./local-video-server scan --verbose

# Использование конфигурационного файла
./local-video-server scan --config config.yaml
```

### Пример вывода:

```
Scanning network: 192.168.1.0/24
Found 5 devices:

┌──────────────┬──────────────┬──────────┬─────────────────────────────┐
│ IP Address   │ Manufacturer │ Model    │ Protocols                   │
├──────────────┼──────────────┼──────────┼─────────────────────────────┤
│ 192.168.1.10 │ Hikvision    │ DS-2CD2  │ RTSP, ONVIF, HTTP           │
│ 192.168.1.11 │ Dahua        │ IPC-HFW  │ RTSP, ONVIF                 │
│ 192.168.1.12 │ TP-Link      │ Tapo C200│ RTSP, HTTP, MJPEG           │
└──────────────┴──────────────┴──────────┴─────────────────────────────┘

RTSP Streams:
  [192.168.1.10] rtsp://192.168.1.10:554/Streaming/Channels/101
    Codec: H.264
    Resolution: 1920x1080
    FPS: 25
    Audio: AAC, 2 channels
    Status: ✓ Available
```

---

## 8. Метрики успеха

- ✅ Обнаружение 95% камер в локальной сети
- ✅ Время сканирования до 100 устройств < 2 минут
- ✅ Поддержка 8+ протоколов видеопотоков
- ✅ Точность определения параметров > 90%
- ✅ Потребление памяти < 100MB
- ✅ Кроссплатформенная работа без зависимостей
- ✅ Работа на Windows, Linux, macOS
- ✅ Поддержка архитектур: x86_64, ARM64, ARM
- ✅ Стабильная работа без падений
- ✅ Понятный вывод результатов

---

## 9. Безопасность и ограничения

### Юридические аспекты:
- Только для сканирования собственных сетей
- Предупреждение о несанкционированном использовании
- Логирование всех действий
- Соблюдение законодательства о защите данных

### Технические ограничения:
- Rate limiting для избежания DoS
- Уважение к таймаутам устройств
- Обработка нестандартных реализаций протоколов
- Проверка на уязвимости (простые пароли)
- Шифрование конфигураций
- Аудит доступа

### Расширяемость:
- Плагинная архитектура для новых протоколов
- Поддержка пользовательских сигнатур
- API для интеграции с другими системами

---

## 10. Риски и митигация

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Медленное сканирование больших сетей | Высокая | Среднее | Параллельное сканирование, настраиваемые таймауты |
| Камеры с нестандартными протоколами | Средняя | Низкое | Расширяемая архитектура, плагины |
| Проблемы с firewall | Средняя | Среднее | Документация по настройке firewall |
| Отсутствие FFmpeg на системе | Низкая | Высокое | Проверка наличия, инструкции по установке |
| Проблемы с кодировками | Низкая | Низкое | UTF-8 везде, правильная обработка |

---

## 11. Дальнейшее развитие

### Возможные улучшения:
1. **Веб-интерфейс** - визуализация обнаруженных камер
2. **REST API** - для интеграции с другими системами
3. **База данных** - хранение истории сканирований
4. **Уведомления** - оповещения о новых устройствах
5. **Автоматическое сканирование** - по расписанию
6. **Мониторинг потоков** - проверка доступности в реальном времени
7. **Экспорт в системы видеонаблюдения** - интеграция с VMS

---

## 12. График разработки (итого: 13-20 недель)

| Этап | Время | Приоритет |
|------|-------|-----------|
| Подготовка | 1-2 недели | Высокий |
| Ядро сканирования сети | 2-3 недели | Высокий |
| Реализация протоколов | 4-6 недель | Высокий |
| Интеграция и парсинг | 2-3 недели | Высокий |
| Интерфейс и отчеты | 2-3 недели | Средний |
| Оптимизация и безопасность | 1-2 недели | Средний |
| Сборка и дистрибуция | 1 неделя | Средний |

**Детальный график:**
- Недели 1-2: Подготовка и настройка
- Недели 3-5: Сетевое сканирование
- Недели 6-11: Реализация протоколов
- Недели 12-14: Интеграция и парсинг
- Недели 15-17: Интерфейс и отчеты
- Недели 18-19: Оптимизация и безопасность
- Неделя 20: Сборка и дистрибуция

---

## 13. Применение

Приложение будет полезно для:

- Администраторов систем безопасности
- Интеграторов систем видеонаблюдения
- Аудиторов информационной безопасности
- Разработчиков IoT решений

---

## 14. Следующие шаги

1. ✅ Создать структуру проекта
2. ✅ Инициализировать Go модуль
3. ✅ Настроить базовую конфигурацию
4. ✅ Реализовать получение сетевых интерфейсов
5. ✅ Начать с простого сканирования портов




